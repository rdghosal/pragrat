use core::fmt;

#[derive(Eq, PartialEq, Clone, Debug)]
pub enum TokenType {
    /// Single-character tokens.
    Colon,
    Comma,
    Dot,
    LBrace,
    LBracket,
    LParen,
    Minus,
    Plus,
    RBrace,
    RBracket,
    RParen,
    Semicolon,
    Slash,
    Star,
    Pipe,

    /// One or two character tokens.
    Bang,
    BangEqual,
    ColonEqual,
    DoubleSlash,
    DoubleSlashEqual,
    DoubleStar,
    DoubleStarEqual,
    Ellipsis,
    Equal,
    EqualEqual,
    Greater,
    GreaterEqual,
    Less,
    LessEqual,
    PlusEqual,
    MinusEqual,
    RArrow,
    StarEqual,
    SlashEqual,

    /// Literals.
    Identifier,
    String,
    Number,
    Indent,
    Dedent,
    NL,
    Newline,

    /// Keywords.
    And,
    As,
    Assert,
    Async,
    Await,
    Break,
    Class,
    Continue,
    Def,
    Del,
    Elif,
    Else,
    Except,
    False,
    Finally,
    For,
    Global,
    If,
    Import,
    In,
    Is,
    Lambda,
    None,
    Nonlocal,
    Not,
    Or,
    Pass,
    Raise,
    Return,
    True,
    Try,
    While,
    With,
    Yield,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TokenType::Colon => write!(f, "Colon"),
            TokenType::Comma => write!(f, "Comma"),
            TokenType::Dot => write!(f, "Dot"),
            TokenType::LBrace => write!(f, "LBrace"),
            TokenType::LBracket => write!(f, "LBracket"),
            TokenType::LParen => write!(f, "LParen"),
            TokenType::Minus => write!(f, "Minus"),
            TokenType::Pipe => write!(f, "Pipe"),
            TokenType::Plus => write!(f, "Plus"),
            TokenType::RBrace => write!(f, "RBrace"),
            TokenType::RBracket => write!(f, "RBracket"),
            TokenType::RParen => write!(f, "RParen"),
            TokenType::Semicolon => write!(f, "Semicolon"),
            TokenType::Slash => write!(f, "Slash"),
            TokenType::Star => write!(f, "Star"),
            TokenType::Bang => write!(f, "Bang"),
            TokenType::BangEqual => write!(f, "BangEqual"),
            TokenType::ColonEqual => write!(f, "ColonEqual"),
            TokenType::DoubleSlash => write!(f, "DoubleSlash"),
            TokenType::DoubleSlashEqual => write!(f, "DoubleSlashEqual"),
            TokenType::DoubleStar => write!(f, "DoubleStar"),
            TokenType::DoubleStarEqual => write!(f, "DoubleStarEqual"),
            TokenType::Ellipsis => write!(f, "Ellipsis"),
            TokenType::Equal => write!(f, "Equal"),
            TokenType::EqualEqual => write!(f, "EqualEqual"),
            TokenType::Greater => write!(f, "Greater"),
            TokenType::GreaterEqual => write!(f, "GreaterEqual"),
            TokenType::Less => write!(f, "Less"),
            TokenType::LessEqual => write!(f, "LessEqual"),
            TokenType::PlusEqual => write!(f, "PlusEqual"),
            TokenType::MinusEqual => write!(f, "MinusEqual"),
            TokenType::RArrow => write!(f, "RArrow"),
            TokenType::StarEqual => write!(f, "StarEqual"),
            TokenType::SlashEqual => write!(f, "SlashEqual"),
            TokenType::Identifier => write!(f, "Identifier"),
            TokenType::String => write!(f, "String"),
            TokenType::Number => write!(f, "Number"),
            TokenType::Indent => write!(f, "Indent"),
            TokenType::Dedent => write!(f, "Dedent"),
            TokenType::NL => write!(f, "NL"),
            TokenType::Newline => write!(f, "Newline"),
            TokenType::And => write!(f, "And"),
            TokenType::As => write!(f, "As"),
            TokenType::Async => write!(f, "Async"),
            TokenType::Await => write!(f, "Await"),
            TokenType::Assert => write!(f, "Assert"),
            TokenType::Break => write!(f, "Break"),
            TokenType::Class => write!(f, "Class"),
            TokenType::Continue => write!(f, "Continue"),
            TokenType::Def => write!(f, "Def"),
            TokenType::Del => write!(f, "Del"),
            TokenType::Elif => write!(f, "Elif"),
            TokenType::Else => write!(f, "Else"),
            TokenType::Except => write!(f, "Except"),
            TokenType::False => write!(f, "False"),
            TokenType::Finally => write!(f, "Finally"),
            TokenType::For => write!(f, "For"),
            TokenType::Global => write!(f, "Global"),
            TokenType::If => write!(f, "If"),
            TokenType::Import => write!(f, "Import"),
            TokenType::In => write!(f, "In"),
            TokenType::Is => write!(f, "Is"),
            TokenType::Lambda => write!(f, "Lambda"),
            TokenType::None => write!(f, "None"),
            TokenType::Nonlocal => write!(f, "Nonlocal"),
            TokenType::Not => write!(f, "Not"),
            TokenType::Or => write!(f, "Or"),
            TokenType::Pass => write!(f, "Pass"),
            TokenType::Raise => write!(f, "Raise"),
            TokenType::Return => write!(f, "Return"),
            TokenType::True => write!(f, "True"),
            TokenType::Try => write!(f, "Try"),
            TokenType::While => write!(f, "While"),
            TokenType::With => write!(f, "With"),
            TokenType::Yield => write!(f, "Yield"),
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub enum Literal {
    String(String),
    Number(String),
}

#[derive(Debug, PartialEq, Eq)]
pub struct Token {
    pub token_type: TokenType,
    pub value: String,
    pub literal: Option<Literal>,
    pub line: usize,
}

impl Token {
    fn to_string(&self) -> String {
        format!("{} {} {}", self.token_type, self.value, self.line)
    }
}
