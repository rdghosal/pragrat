use core::fmt;

#[derive(Eq, PartialEq, Clone, Debug)]
pub enum TokenType {
    /// Single-character tokens.
    LPar,
    RPar,
    LSqB,
    RSqB,
    Colon,
    Comma,
    Semi,
    Plus,
    Minus,
    Star,
    Slash,
    VBar,
    Amper,
    Less,
    Greater,
    Equal,
    Dot,
    Percent,
    LBrace,
    RBrace,

    /// Two or three-character tokens.
    EqEqual,
    NotEqual,
    LessEqual,
    GreaterEqual,
    Tilde,
    Circumflex,
    LeftShift,
    RightShift,
    DoubleStar,
    PlusEqual,
    MinEqual,
    StarEqual,
    SlashEqual,
    PercentEqual,
    AmperEqual,
    VBarEqual,
    CircumflexEqual,
    LeftShiftEqual,
    RightShiftEqual,
    DoubleStarEqual,
    DoubleSlash,
    DoubleSlashEqual,
    At,
    AtEqual,
    RArrow,
    Ellipsis,
    ColonEqual,
    Exclamation,

    /// Literals.
    Endmarker,
    Name,
    Number,
    String,
    Newline,
    Indent,
    Dedent,

    /// Keywords.
    And,
    As,
    Assert,
    Break,
    Class,
    Continue,
    Def,
    Del,
    Elif,
    Else,
    Except,
    False,
    Finally,
    For,
    Global,
    If,
    Import,
    In,
    Is,
    Lambda,
    None,
    Nonlocal,
    Not,
    Or,
    Pass,
    Raise,
    Return,
    True,
    Try,
    While,
    With,
    Yield,

    /// Other.
    Op,
    Await,
    Async,
    TypeIgnore,
    TypeComment,
    SoftKeyword,
    FStringStart,
    FStringMiddle,
    FStringEnd,
    Comment,
    NL,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TokenType::LPar => write!(f, "LPar"),
            TokenType::RPar => write!(f, "RPar"),
            TokenType::LSqB => write!(f, "LSqB"),
            TokenType::RSqB => write!(f, "RSqB"),
            TokenType::Colon => write!(f, "Colon"),
            TokenType::Comma => write!(f, "Comma"),
            TokenType::Semi => write!(f, "Semi"),
            TokenType::Plus => write!(f, "Plus"),
            TokenType::Minus => write!(f, "Minus"),
            TokenType::Star => write!(f, "Star"),
            TokenType::Slash => write!(f, "Slash"),
            TokenType::VBar => write!(f, "VBar"),
            TokenType::Amper => write!(f, "Amper"),
            TokenType::Less => write!(f, "Less"),
            TokenType::Greater => write!(f, "Greater"),
            TokenType::Equal => write!(f, "Equal"),
            TokenType::Dot => write!(f, "Dot"),
            TokenType::Percent => write!(f, "Percent"),
            TokenType::LBrace => write!(f, "LBrace"),
            TokenType::RBrace => write!(f, "RBrace"),
            TokenType::EqEqual => write!(f, "EqEqual"),
            TokenType::NotEqual => write!(f, "NotEqual"),
            TokenType::LessEqual => write!(f, "LessEqual"),
            TokenType::GreaterEqual => write!(f, "GreaterEqual"),
            TokenType::Tilde => write!(f, "Tilde"),
            TokenType::Circumflex => write!(f, "Circumflex"),
            TokenType::LeftShift => write!(f, "LeftShift"),
            TokenType::RightShift => write!(f, "RightShift"),
            TokenType::DoubleStar => write!(f, "DoubleStar"),
            TokenType::PlusEqual => write!(f, "PlusEqual"),
            TokenType::MinEqual => write!(f, "MinEqual"),
            TokenType::StarEqual => write!(f, "StarEqual"),
            TokenType::SlashEqual => write!(f, "SlashEqual"),
            TokenType::PercentEqual => write!(f, "PercentEqual"),
            TokenType::AmperEqual => write!(f, "AmperEqual"),
            TokenType::VBarEqual => write!(f, "VBarEqual"),
            TokenType::CircumflexEqual => write!(f, "CircumflexEqual"),
            TokenType::LeftShiftEqual => write!(f, "LeftShiftEqual"),
            TokenType::RightShiftEqual => write!(f, "RightShiftEqual"),
            TokenType::DoubleStarEqual => write!(f, "DoubleStarEqual"),
            TokenType::DoubleSlash => write!(f, "DoubleSlash"),
            TokenType::DoubleSlashEqual => write!(f, "DoubleSlashEqual"),
            TokenType::At => write!(f, "At"),
            TokenType::AtEqual => write!(f, "AtEqual"),
            TokenType::RArrow => write!(f, "RArrow"),
            TokenType::Ellipsis => write!(f, "Ellipsis"),
            TokenType::ColonEqual => write!(f, "ColonEqual"),
            TokenType::Exclamation => write!(f, "Exclamation"),
            TokenType::Endmarker => write!(f, "Endmarker"),
            TokenType::Name => write!(f, "Name"),
            TokenType::Number => write!(f, "Number"),
            TokenType::String => write!(f, "String"),
            TokenType::Newline => write!(f, "Newline"),
            TokenType::Indent => write!(f, "Indent"),
            TokenType::Dedent => write!(f, "Dedent"),
            TokenType::Op => write!(f, "Op"),
            TokenType::Await => write!(f, "Await"),
            TokenType::Async => write!(f, "Async"),
            TokenType::TypeIgnore => write!(f, "TypeIgnore"),
            TokenType::TypeComment => write!(f, "TypeComment"),
            TokenType::SoftKeyword => write!(f, "SoftKeyword"),
            TokenType::FStringStart => write!(f, "FStringStart"),
            TokenType::FStringMiddle => write!(f, "FStringMiddle"),
            TokenType::FStringEnd => write!(f, "FStringEnd"),
            TokenType::Comment => write!(f, "Comment"),
            TokenType::NL => write!(f, "NL"),
            TokenType::And => write!(f, "And"),
            TokenType::As => write!(f, "As"),
            TokenType::Assert => write!(f, "Assert"),
            TokenType::Break => write!(f, "Break"),
            TokenType::Class => write!(f, "Class"),
            TokenType::Continue => write!(f, "Continue"),
            TokenType::Def => write!(f, "Def"),
            TokenType::Del => write!(f, "Del"),
            TokenType::Elif => write!(f, "Elif"),
            TokenType::Else => write!(f, "Else"),
            TokenType::Except => write!(f, "Except"),
            TokenType::False => write!(f, "False"),
            TokenType::Finally => write!(f, "Finally"),
            TokenType::For => write!(f, "For"),
            TokenType::Global => write!(f, "Global"),
            TokenType::If => write!(f, "If"),
            TokenType::Import => write!(f, "Import"),
            TokenType::In => write!(f, "In"),
            TokenType::Is => write!(f, "Is"),
            TokenType::Lambda => write!(f, "Lambda"),
            TokenType::None => write!(f, "None"),
            TokenType::Nonlocal => write!(f, "Nonlocal"),
            TokenType::Not => write!(f, "Not"),
            TokenType::Or => write!(f, "Or"),
            TokenType::Pass => write!(f, "Pass"),
            TokenType::Raise => write!(f, "Raise"),
            TokenType::Return => write!(f, "Return"),
            TokenType::True => write!(f, "True"),
            TokenType::Try => write!(f, "Try"),
            TokenType::While => write!(f, "While"),
            TokenType::With => write!(f, "With"),
            TokenType::Yield => write!(f, "Yield"),
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub enum Literal {
    String(String),
    Number(String),
}

#[derive(Debug, PartialEq, Eq)]
pub struct Token {
    pub token_type: TokenType,
    pub value: String,
    pub literal: Option<Literal>,
    pub line: usize,
}

impl Token {
    fn to_string(&self) -> String {
        format!("{} {} {}", self.token_type, self.value, self.line)
    }
}
